import axios, { AxiosRequestConfig } from 'axios'
import proxymise from './proxymise'

export type Method = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'CONNECT' | 'TRACE'

/*
 * Key-Value object type.
 */
export interface KVO<T = any> {
  [key: string]: T
}

/**
 * XhrRef xhr reference, used to abort/force retrying, etc...
 */
export interface XhrRef {
  abort(options?: { ignoreRetry: boolean }): void // abort the request
  retryImmediately(): void // skip current retry waiting strategy and retry the request immediately
}

/**
 * XHR Request.
 */
export interface XhrRequest {
  url?: string
  params?: KVO
  headers?: KVO
  data?: any
  options?: KVO
}

/**
 * XHR Response.
 */
export interface XhrResponse<T> {
  status: number
  statusText: string
  headers?: KVO
  response?: T
  error?: any
  request: XhrRequest
  extra?: any
}

export interface ExtendedPromise<T extends XhrResponse<any>> extends Promise<T> {
  as<U extends string>(key: U): Promise<Omit<T, 'response'> & Record<U, T['response']> & { response: undefined }>
}

/**
 * Retry after a delay. If the function returns non-positive number, retry will stop.
 */
export type XhrRetryAfter = (params: { counter: number; lastStatus: number }) => number

/**
 * Request Options extends AxiosRequestConfig with xhr setter support.
 * @export
 * @interface RequestOptions
 * @extends {AxiosRequestConfig}
 */
export interface XhrOptions<U = any> extends AxiosRequestConfig, KVO {
  ref?: (request?: XhrRef) => void

  // xhr group, used to terminate a batch of xhr requests
  group?: string

  // retry if failed
  retry?: number | XhrRetryAfter
  data?: U
}

/**
 * Before Interceptor.
 */
export type XhrBeforeInterceptor = (args: XhrRequest) => void

/**
 * After Interceptor.
 */
export type XhrAfterInterceptor = (args: XhrResponse<any>) => void

const beforeInterceptors: XhrBeforeInterceptor[] = []
const afterInterceptors: XhrAfterInterceptor[] = []

export interface XhrInterceptorOptions {
  first?: boolean
  replaceAll?: boolean
}
/**
 * Inject an interceptor before a request is being made.
 * @param interceptor interceptor.
 */
const before = (interceptor: XhrBeforeInterceptor, options?: XhrInterceptorOptions) => {
  options = options || {}

  if (options.first) {
    beforeInterceptors.unshift(interceptor)
  } else if (options.replaceAll) {
    beforeInterceptors.splice(0, beforeInterceptors.length, interceptor)
  } else {
    beforeInterceptors.push(interceptor)
  }
}

/**
 * Inject an interceptor after a response is returned.
 * @param interceptor interceptor.
 */
const after = (interceptor: XhrAfterInterceptor) => afterInterceptors.push(interceptor)

//
// Xhr groups is used to store on-going requests.
//
const xhrGroups: KVO<KVO<XhrRef>> = {}

//
// On-going requests are stored in requests and will be cleaned up
// when they are finished
//
export interface RequestTrackingInfo {
  config: XhrOptions
  status?: number
  startTime: number
}

//
// requests maintains information of all on-going requests
//
const requests: KVO<RequestTrackingInfo> = {}

//
// Unique auto-generated id for each request
//
let autoGeneratedId: number = 0

//
// Status constants
//
const UNREACHABLE = 0
const ABORTED = -1
const TIMEOUT = -2

//
// Intercept axios request to inject cancel token, set/unset xhr, etc...
//
axios.interceptors.request.use(
  (config: XhrOptions) => {
    const { ref, group, retry } = config
    const id = config.id as string

    // save options into requests for reference
    requests[id] = { config, startTime: +new Date() }

    if (ref || group) {
      config.cancelToken = new axios.CancelToken(cancel => {
        const requestRef: XhrRef = {
          abort: options => {
            cancel()

            const _id = config.id as string // get latest id from config (it may be changed during retrying)

            if (ref) {
              ref(undefined) // unset xhr reference
            }

            if (group) {
              delete xhrGroups[group][id]
            }

            // Set request status if only the request's info in requests still exists.
            // In case of retry, this information is removed during setTimeout delay
            if (requests[_id]) {
              requests[_id].status = ABORTED
            }

            if (options && options.ignoreRetry) {
              const retryAfter = typeof retry !== 'number' && (retry as KVO)

              if (retryAfter) {
                retryAfter.cancelRetry()
              }
            }
          },

          retryImmediately: () => {
            const retryAfter = typeof retry !== 'number' && (retry as KVO)

            if (retryAfter) {
              retryAfter.retryImmediately()
            }
          }
        }

        if (group) {
          xhrGroups[group] = xhrGroups[group] || {}
          xhrGroups[group][id] = requestRef
        }

        // call xhr so caller has a change to save the xhr object with abort()/retry() capability
        if (ref) {
          ref(requestRef)
        }
      })
    }

    return config
  },
  (error: any) => Promise.reject(error)
)

//
// Intercept axios response to unset xhr.
//
axios.interceptors.response.use(
  (response: any) => {
    const { ref, id, group } = response.config as XhrOptions & KVO

    // call ref() to pass undefined so caller has a chance to set its xhr reference to undefined
    if (ref) {
      ref(undefined)
    }

    if (group) {
      delete xhrGroups[group][id as string]

      if (!Object.keys(xhrGroups[group]).length) {
        delete xhrGroups[group]
      }
    }

    delete requests[id as string]

    return response
  },
  (error: any) => Promise.reject(error)
)

function cleanupRetry(retry?: XhrRetryAfter | number, ignoreCounter: boolean = true) {
  const retryAfter = retry && typeof retry !== 'number' && (retry as KVO)

  if (retryAfter) {
    if (ignoreCounter) {
      delete retryAfter.counter
    }
    delete retryAfter.timeoutId
    delete retryAfter.retryImmediately
    delete retryAfter.cancelRetry
  }
}

async function ajax<T>(url: string, options: XhrOptions = {}, extra?: KVO): Promise<XhrResponse<T>> {
  let xhrResponse: XhrResponse<T>

  // add extra id property to track back to config when exception occurs
  const id = ++autoGeneratedId + '-' + new Date().getTime()
  options.id = id
  options.url = url
  options.headers = options.headers || {}

  beforeInterceptors.forEach(interceptor =>
    interceptor({ url, headers: options.headers, params: options.params, data: options.data, options })
  )

  try {
    const { status, statusText, headers: responseHeaders, data: responseData, config } = await axios(options)
    const { params, data, headers } = config

    cleanupRetry(options.retry)

    xhrResponse = {
      status,
      statusText,
      response: responseData,
      headers: responseHeaders,
      request: { url, params, data, headers },
      extra
    }
  } catch (error) {
    const { response } = error
    const headers = response && response.headers
    const request = requests[id]
    const { config } = request
    let status = request.status || (response && response.status) || UNREACHABLE

    // Determine if request is timeout
    if (status === UNREACHABLE && !!config.timeout) {
      const duration = +new Date() - request.startTime
      if (duration >= config.timeout) {
        status = TIMEOUT
      }
    }

    delete requests[id]

    const generateErrorResult = (optionalStatus?: number): XhrResponse<T> => {
      const { ref } = options
      const { params = undefined, data = undefined, headers: requestHeaders = {} } = config || {}

      if (ref) {
        ref(undefined) // unset xhr
      }

      return {
        status: optionalStatus || status,
        statusText: (response && response.statusText) || error.toString(),
        headers,
        response: response && response.data,
        error,
        request: { url, params, data, headers: requestHeaders },
        extra
      }
    }

    if (options.retry) {
      if (typeof options.retry === 'number' && options.retry > 0) {
        options.retry--
        return ajax(url, options)
      } else {
        // trick to add extra counter and timeoutId into retryAfter
        const retryAfter = options.retry as XhrRetryAfter & KVO
        const { counter, timeoutId } = retryAfter
        retryAfter.counter = (counter || 0) + 1

        if (timeoutId) {
          clearTimeout(timeoutId)
        }

        const delay = retryAfter({ counter: retryAfter.counter, lastStatus: status })

        if (delay >= 0) {
          return new Promise<XhrResponse<T>>(resolve => {
            retryAfter.timeoutId = setTimeout(() => {
              resolve(ajax(url, options))
              cleanupRetry(retryAfter, false)
            }, delay)

            retryAfter.retryImmediately = () => {
              clearTimeout(retryAfter.timeoutId)
              resolve(ajax(url, options))
              cleanupRetry(retryAfter, false)
            }

            retryAfter.cancelRetry = () => {
              clearTimeout(retryAfter.timeoutId)
              cleanupRetry(retryAfter)
              resolve(generateErrorResult(ABORTED))
            }
          })
        } else {
          cleanupRetry(retryAfter)
        }
      }
    }

    xhrResponse = generateErrorResult()
    xhrResponse.extra = extra
  }

  afterInterceptors.forEach(interceptor => interceptor(xhrResponse))

  return new Proxy(xhrResponse, {
    get: (target, name: string) => {
      return name === 'as'
        ? (as: string) => {
            ;(xhrResponse as KVO)[as] = xhrResponse.response
            delete xhrResponse.response
            return xhrResponse
          }
        : (target as KVO)[name]
    }
  })
}

export type Request = <T, U = any>(url: string, options?: XhrOptions<U>, extra?: KVO) => ExtendedPromise<XhrResponse<T>>

export function requestFor(method: Method): Request {
  return proxymise(
    async <T, U>(url: string, options: XhrOptions<U> = {}, extra?: KVO): Promise<XhrResponse<T>> => {
      options.method = method
      return ajax(url, options, extra)
    }
  )
}

function abort(group: string) {
  const xhrGroup = xhrGroups[group]

  if (xhrGroup) {
    Object.keys(xhrGroup).forEach(id => {
      const request = xhrGroup[id]
      if (request) {
        request.abort()
      }
    })
    delete xhrGroups[group]
  }
}

const xhr = {
  get: requestFor('GET'),
  post: requestFor('POST'),
  put: requestFor('PUT'),
  delete: requestFor('DELETE'),
  head: requestFor('HEAD'),
  connect: requestFor('CONNECT'),
  options: requestFor('OPTIONS'),
  trace: requestFor('TRACE'),
  patch: requestFor('PATCH'),

  abort,

  // @see https://github.com/mzabriskie/axios#global-axios-defaults
  defaults: axios.defaults,

  before,
  after,

  ABORTED,
  TIMEOUT,
  UNREACHABLE
}

//
// Make xhr readonly at runtime
//
Object.keys(xhr).forEach(key =>
  Object.defineProperty(xhr, key, {
    value: (xhr as KVO)[key],
    writable: false,
    configurable: false,
    enumerable: true
  })
)

export default xhr

//
// TODO:
//
// - Run httpbin locally
// - More tests (binary, stream, etc)
// - Write README
// - Plugins:
//    + Detect null, undefined in url -> warning logs
//    + Log (track to caller)
